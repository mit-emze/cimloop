compound_components:
  version: 0.4         # REQUIRED version number
  classes:
  ### CORRECT
  - name: smartbuffer_sram_v2
    attributes:
      technology: TECHNOLOGY
      width: "must_specify"
      depth: "must_specify"
      n_rw_ports: 1
      global_cycle_seconds: GLOBAL_CYCLE_SECONDS

    subcomponents:
    - name: storage
      class: SRAM
      attributes:
        width: width
        depth: depth
        n_rw_ports: n_rw_ports
        technology: technology
        global_cycle_seconds: global_cycle_seconds
    
    # We don't need to scale the address generators
    - name: address_generator
      class: aladdin_adder
      attributes:
        technology: technology
        n_instances: 2 # One for read, one for write
        n_bits: max(1, ceil(log2(depth))) if depth >= 1 else 1
        precision: max(1, ceil(log2(depth))) if depth >= 1 else 1
        datawidth: max(1, ceil(log2(depth))) if depth >= 1 else 1
        global_cycle_seconds: global_cycle_seconds

    actions:
    - &write_action
      name: write 
      subcomponents:
      - name: storage
        actions: [{name: write}]
      - name: address_generator
        actions: [{name: add}]
    - name: read
      subcomponents:
      - name: storage
        actions: [{name: read}]
      - name: address_generator
        actions: [{name: add}]
    - name: leak
      subcomponents:
      - name: storage
        actions: [{name: leak}]
      - name: address_generator
        actions: [{name: leak}]
    - name: update
      << : *write_action # Update is the same as write


    # SOFTMAX STUFF
  - name: approx_softmax # for use in the PPU
    attributes:
        width: 256//PRECISION
        depth: 1
        technology: TECHNOLOGY
        global_cycle_seconds: GLOBAL_CYCLE_SECONDS
        precision: PRECISION
        voltage: VOLTAGE
    subcomponents:
    - name: adds 
      class: aladdin_adder
      attributes:
        technology: technology
        voltage: voltage
        n_instances: ceil(log2(width)) + width + 2 #the number of adds that I saw
        width: precision
        global_cycle_seconds: global_cycle_seconds
    # - name: shifts 
    #   class: aladdin_shifter
    #   attributes:
    #     technology: technology
    #     voltage: voltage
    #     n_instances: width + 1 #the number of shifts that I saw
    #     width: precision
    #     global_cycle_seconds: global_cycle_seconds
    - name: comparisons 
      class: aladdin_comparator
      attributes:
        technology: technology
        voltage: voltage
        n_instances: ceil(log2(width)) + 1 #the number of comparisons that I saw
        width: precision
        global_cycle_seconds: global_cycle_seconds
    actions:
    - &write_action 
      name: write #have it called write because you need a read/write
      subcomponents: []
    - name: read
      subcomponents:
      - name: adds
        actions: [{name: read}]
      # - name: shifts
      #   actions: [{name: read}]
      - name: comparisons
        actions: [{name: read}]
    - name: leak
      subcomponents:
      - name: adds
        actions: [{name: leak}]
      # - name: shifts
      #   actions: [{name: leak}]
      - name: comparisons
        actions: [{name: leak}]
    - name: update
      << : *write_action # Update is the same as write
    
              
  ## int4 datapath
  - name: int4_datapath
    attributes:
        width: 4
        depth: 1
        global_cycle_seconds: GLOBAL_CYCLE_SECONDS
        technology: TECHNOLOGY
        
    subcomponents:
    - name: int4_multiplier ## 4x4 multiplier (MAC)
      class: aladdin_multiplier
      attributes:
          technology: technology
          width_a: 4
          width_b: 4
          width: 8
    - name: int4_adder ## adder (MAC)
      class: aladdin_adder
      attributes:
          technology: technology
          global_cycle_seconds: global_cycle_seconds
          width: 14
    - name: int4_partialsum ## partial sum after MAC
      class: aladdin_adder
      attributes:
          width: 24
          global_cycle_seconds: global_cycle_seconds
          technology: technology
          depth: 1
          
    actions:
    - &write_action
      name: write
      subcomponents: 
      - name: int4_multiplier
        actions: [{name: write}]
      - name: int4_adder
        actions: [{name: write}]
      - name: int4_partialsum
        actions: [{name: write, energy_scale: 1/64}]
    - &read_action
      name: read
      subcomponents:
      - name: int4_multiplier
        actions: [{name: multiply}]
      - name: int4_adder
        actions: [{name: add}]
      - name: int4_partialsum
        actions: [{name: add, energy_scale: 1/64}]
    - name: leak
      subcomponents:
      - name: int4_multiplier
        actions: [{name: leak}]
      - name: int4_adder
        actions: [{name: leak}]
      - name: int4_partialsum
        actions: [{name: leak, energy_scale: 1/64}]
    - name: update
      << : *write_action # Update is the same as write
    - name: compute
      << : *read_action

  ## int4 VSQ datapath
  # - name: int4vsq_datapath
  #   attributes:
  #       width: 4
  #       depth: 1
        
  #   subcomponents:
  #   - name: int4vsq_multiplier ## 4x4 multiplier (MAC)
  #     class: aladdin_multiplier
  #     attributes:
  #         technology: TECHNOLOGY
  #         width_a: 4
  #         width_b: 4
  #         width: 8
  #         depth: 1
  #   - name: int4vsq_adder ## adder (MAC)
  #     class: aladdin_adder
  #     attributes:
  #         technology: TECHNOLOGY
  #         global_cycle_seconds: GLOBAL_CYCLE_SECONDS
  #         width: 14
  #         depth: 1
  #   - name: rounding_multiplication ## 8x8 multipliation before rounding
  #     class: aladdin_multiplier 
  #     attributes:
  #         technology: TECHNOLOGY
  #         width_a: 8
  #         width_b: 8
  #         width: 16
  #         depth: 1
  #   - name: saturation_multiplication ## 14x8 multiplication before saturation
  #     class: aladdin_multiplier
  #     attributes:
  #         technology: TECHNOLOGY
  #         width_a: 14
  #         width_b: 8
  #         width: 22
  #         depth: 1
  #   - name: int4vsq_partialsum ## partial adder
  #     class: aladdin_adder
  #     attributes:
  #         technology: TECHNOLOGY
  #         global_cycle_seconds: GLOBAL_CYCLE_SECONDS
  #         width: 24
  #         depth: 1

  #   actions:
  #   - &write_action
  #     name: write
  #   - name: read
  #     subcomponents:
  #     - name: int4vsq_multiplier
  #       actions: [{name: multiply, energy_scale: 64}]
  #     - name: int4vsq_adder
  #       actions: [{name: add, energy_scale: 64}]
  #     - name: rounding_multiplication
  #       actions: [{name: multiply}]
  #     - name: saturation_multiplication
  #       actions: [{name: multiply}]
  #     - name: int4vsq_partialsum
  #       actions: [{name: add}]
  #   - name: leak
  #     subcomponents:
  #     - name: int4vsq_multiplier
  #       actions: [{name: leak}]
  #     - name: int4vsq_adder
  #       actions: [{name: leak}]
  #     - name: rounding_multiplication
  #       actions: [{name: leak}]
  #     - name: saturation_multiplication
  #       actions: [{name: leak}]
  #     - name: int4vsq_partialsum
  #       actions: [{name: leak}]
  #   - name: update
  #     << : *write_action # Update is the same as write
  #   ## did not model saturation and rounding
    
      ## in actions add a aprameter names energy_scale = factor (num of component)
 
     #3xAND gate for selecting mode/ all things always run but just get 0 mults most of the time?
 
 #     #subcomponents for 8 bit
 #     # 32 8bitx8bit multiples
 #     # intadder with 32 inputs of size 16bits and 1 output of size 21 bits
 #     # intadder with 2 inputs, 24 bit and 21 bit, then 1 output of 24 bits (gated by mode selection)

 #     # subcomponents for 4 bit
 #     # 64 4bitx4bit multiples
 #     # intadder with 64 inputs of size 8bits and 1 output of size 14 bits
 #     # intadder with 2 inputs, 24 bit and 14 bit, then 1 output of 24 bits (gated by mode selection)

 #     #subcomponents for vsq
 #     #8bitx8bit multiply
 #     #skip rounding?
 #     #14bitx8bit multiply
 #     #22bitx24bit add (gated by mode selection)
 #     #skip saturation ?
 #     #24 bit output

     #mux for partial sum out

     ## second cell - unspecified (width and depth), or file for outputs (read timeloop mapper - find errors)
     
    
 # -name: latch_array
 #    # can maybr just model this as an SRAM? idk
 # -name: approx_softmax
 #  # Big diagram for softmax in doc
  - name: ppu
    attributes:
        width: 4
        depth: 1
    subcomponents:
    - name: matrix_scaler #idk if this is supposed to be spatial
      class: aladdin_multiplier
      attributes:
         technology: TECHNOLOGY
         width_a: 24 #partial sum value ?
         width_b: 8  # scale factor?
         width: 32 # no clue, just did min number of bits needed to represent 24x8 bits
         depth: 1
    - name: bias_adder
      class: aladdin_adder
      attributes:
         technology: TECHNOLOGY # using smallest aladdin tech size
         global_cycle_seconds: GLOBAL_CYCLE_SECONDS
         width: 640 # just using only number that is shown
         depth: 1
    - name: scale_buffer
      class: smartbuffer_sram_v2
      attributes:
         depth: 8
         width: 256
    - name: bias_buffer
      class: smartbuffer_sram_v2
      attributes:
         depth: 8
         width: 128
    - name: approx_softmax
      class: approx_softmax

    actions:
    - &write_action # act of setting values for buffers
      name: write #have it called write because you need a read/write
      subcomponents:
      - name: scale_buffer
        actions: [{name: write}]
      - name: bias_buffer
        actions: [{name: write}]
      - name: approx_softmax
        actions: [{name: write}]
    - name: read
      subcomponents:
      - name: scale_buffer
        actions: [{name: read}]
      - name: bias_buffer
        actions: [{name: read}]
      - name: matrix_scaler
        actions: [{name: multiply}]
      - name: bias_adder
        actions: [{name: add}]
      - name: approx_softmax
        actions: [{name: read}]
    - name: leak
      subcomponents:
      - name: scale_buffer
        actions: [{name: leak}]
      - name: bias_buffer
        actions: [{name: leak}]
      - name: matrix_scaler
        actions: [{name: leak}]
      - name: bias_adder
        actions: [{name: leak}]
      - name: approx_softmax
        actions: [{name: leak}]
    - name: update
      << : *write_action # Update is the same as write
      
    
  
     
   
 