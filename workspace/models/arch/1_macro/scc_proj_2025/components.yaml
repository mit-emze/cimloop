compound_components:
  version: 0.4         # REQUIRED version number
  classes:
  - name: smartbuffer_sram_components_dot_yaml
    attributes:
      technology: "must_specify"
      width: "must_specify"
      depth: "must_specify"
      n_rw_ports: 1
      global_cycle_seconds: "must_specify"

    subcomponents:
    - name: storage
      class: SRAM
      attributes:
        width: width
        depth: depth
        n_rw_ports: n_rw_ports
        technology: technology
        global_cycle_seconds: global_cycle_seconds
    
    # We don't need to scale the address generators
    - name: address_generator
      class: intadder
      attributes:
        n_instances: 2 # One for read, one for write
        n_bits: max(1, ceil(log2(depth))) if depth >= 1 else 1
        precision: max(1, ceil(log2(depth))) if depth >= 1 else 1
        datawidth: max(1, ceil(log2(depth))) if depth >= 1 else 1
        global_cycle_seconds: global_cycle_seconds

    actions:
    - &write_action
      name: write 
      subcomponents:
      - name: storage
        actions: [{name: write}]
      - name: address_generator
        actions: [{name: add}]
    - name: read
      subcomponents:
      - name: storage
        actions: [{name: read}]
      - name: address_generator
        actions: [{name: add}]
    - name: leak
      subcomponents:
      - name: storage
        actions: [{name: leak}]
      - name: address_generator
        actions: [{name: leak}]
    - name: update
      << : *write_action # Update is the same as write
 -name: vec_datapath
     #3xAND gate for selecting mode/ all things always run but just get 0 mults most of the time?
 
     #subcomponents for 8 bit
     # 32 8bitx8bit multiples
     # intadder with 32 inputs of size 16bits and 1 output of size 21 bits
     # intadder with 2 inputs, 24 bit and 21 bit, then 1 output of 24 bits (gated by mode selection)

     # subcomponents for 4 bit
     # 64 4bitx4bit multiples
     # intadder with 64 inputs of size 8bits and 1 output of size 14 bits
     # intadder with 2 inputs, 24 bit and 14 bit, then 1 output of 24 bits (gated by mode selection)

     #subcomponents for vsq
     #8bitx8bit multiply
     #skip rounding?
     #14bitx8bit multiply
     #22bitx24bit add (gated by mode selection)
     #skip saturation ?
     #24 bit output

     #mux for partial sum out
     
     
 -name: latch_array
    # can maybr just model this as an SRAM? idk
 -name: approx_softmax
  # Big diagram for softmax in doc
 