compound_components:
  version: 0.4         # REQUIRED version number
  classes:
  - name: smartbuffer_sram_v2
    attributes:
      technology: "must_specify"
      width: "must_specify"
      depth: "must_specify"
      n_rw_ports: 1
      global_cycle_seconds: "must_specify"

    subcomponents:
    - name: storage
      class: SRAM
      attributes:
        width: width
        depth: depth
        n_rw_ports: n_rw_ports
        technology: technology
        global_cycle_seconds: global_cycle_seconds
    
    # We don't need to scale the address generators
    - name: address_generator
      class: aladdin_adder
      attributes:
        technology: technology
        n_instances: 2 # One for read, one for write
        n_bits: max(1, ceil(log2(depth))) if depth >= 1 else 1
        precision: max(1, ceil(log2(depth))) if depth >= 1 else 1
        datawidth: max(1, ceil(log2(depth))) if depth >= 1 else 1
        global_cycle_seconds: global_cycle_seconds

    actions:
    - &write_action
      name: write 
      subcomponents:
      - name: storage
        actions: [{name: write}]
      - name: address_generator
        actions: [{name: add}]
    - name: read
      subcomponents:
      - name: storage
        actions: [{name: read}]
      - name: address_generator
        actions: [{name: add}]
    - name: leak
      subcomponents:
      - name: storage
        actions: [{name: leak}]
      - name: address_generator
        actions: [{name: leak}]
    - name: update
      << : *write_action # Update is the same as write
 # -name: vec_datapath
 #     #3xAND gate for selecting mode/ all things always run but just get 0 mults most of the time?
 
 #     #subcomponents for 8 bit
 #     # 32 8bitx8bit multiples
 #     # intadder with 32 inputs of size 16bits and 1 output of size 21 bits
 #     # intadder with 2 inputs, 24 bit and 21 bit, then 1 output of 24 bits (gated by mode selection)

 #     # subcomponents for 4 bit
 #     # 64 4bitx4bit multiples
 #     # intadder with 64 inputs of size 8bits and 1 output of size 14 bits
 #     # intadder with 2 inputs, 24 bit and 14 bit, then 1 output of 24 bits (gated by mode selection)

 #     #subcomponents for vsq
 #     #8bitx8bit multiply
 #     #skip rounding?
 #     #14bitx8bit multiply
 #     #22bitx24bit add (gated by mode selection)
 #     #skip saturation ?
 #     #24 bit output

 #     #mux for partial sum out
     
     
 # -name: latch_array
 #    # can maybr just model this as an SRAM? idk
 # -name: approx_softmax
 #  # Big diagram for softmax in doc
  - name: ppu
    attributes:
        width: 4
        depth: 1
    subcomponents:
    - name: matrix_scaler #idk if this is supposed to be spatial
      class: aladdin_multiplier
      attributes:
         technology: "5nm"
         width_a: 24 #partial sum value ?
         width_b: 8  # scale factor?
         width: 32 # no clue, just did min number of bits needed to represent 24x8 bits
         depth: 1

    - name: bias_adder
      class: aladdin_adder
      attributes:
         technology: "5nm" # using smallest aladdin tech size
         global_cycle_seconds: GLOBAL_CYCLE_SECONDS
         width: 640 # just using only number that is shown
         depth: 1
    - name: scale_buffer
      class: smartbuffer_sram_v2
      attributes:
         technology: "5nm"
         depth: 8
         width: 256
         global_cycle_seconds: GLOBAL_CYCLE_SECONDS
    - name: bias_buffer
      class: smartbuffer_sram_v2
      attributes:
         technology: "5nm"
         depth: 8
         width: 128
         global_cycle_seconds: GLOBAL_CYCLE_SECONDS
    actions:
    - &write_action # act of setting values for buffers
      name: write #have it called write because you need a read/write
      subcomponents:
      - name: scale_buffer
        actions: [{name: write}]
      - name: bias_buffer
        actions: [{name: write}]
    - name: read
      subcomponents:
      - name: scale_buffer
        actions: [{name: read}]
      - name: bias_buffer
        actions: [{name: read}]
      - name: matrix_scaler
        actions: [{name: multiply}]
      - name: bias_adder
        actions: [{name: add}]
    - name: leak
      subcomponents:
      - name: scale_buffer
        actions: [{name: leak}]
      - name: bias_buffer
        actions: [{name: leak}]
      - name: matrix_scaler
        actions: [{name: leak}]
      - name: bias_adder
        actions: [{name: leak}]
    - name: update
      << : *write_action # Update is the same as write
    
  
     
   
 